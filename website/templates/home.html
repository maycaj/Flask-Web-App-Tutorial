{% extends "base.html" %} 
{% block title %}MedNote{% endblock %} 
{% block content %}
<h1 align="center">MedNote</h1>
<p class="text-center font-italic"> Click start recording while speaking with your physician to summarize the interaction </p> 
<ul class="list-group list-group-flush" id="notes">
  {% for note in user.notes %}
  <li class="list-group-item">
    <audio controls>
      <source src="{{ url_for('views.get_audio', note_id=note.id) }}" type="audio/wav">
      Your browser does not support audio playback.
    </audio>
    <p class="mt-2"><strong>Transcription:</strong><br></p>
    <pre style="font-family: inherit; white-space: pre-wrap; font-size: 16px;">{{ note.transcription }}</pre>
    <p class="mt-2"><strong>Explanation and Notes:</strong><br></p>
    <pre style="font-family: inherit; white-space: pre-wrap; font-size: 16px;">{{ note.analysis }}</pre>
    <small class="text-muted">{{ note.date.strftime('%Y-%m-%d %H:%M:%S') }}</small>
    <button type="button" class="close" data-note-id="{{ note.id }}" onclick="deleteNote(this.getAttribute('data-note-id'))">
      <span aria-hidden="true">&times;</span>
    </button>
  </li>
  {% endfor %}
</ul>

<div class="mt-4" align="center">
  <button id="startRecord" class="btn btn-primary">Start Recording</button>
  <span id="timer">00:00:00</span>
  <button id="stopRecord" class="btn btn-danger" disabled>Stop Recording</button>
</div>

<div id="loadingText" style="display: none; text-align: center; font-weight: bold;">
  Saving Mednote <span id="loadingDots"></span>
</div>

<div align="center">
  <br>
  <p class="text-center font-italic">AI is experimental – double check important information </p>
  <br>
  <br>
  <br>
  <br>
  <br>
  <br>
</div>
{% endblock %}

{% block javascript %}
<script>let mediaRecorder;
  let audioChunks = [];
  
  document.getElementById('startRecord').addEventListener('click', async () => {
      try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
              audio: {
                  channelCount: 1,
                  sampleRate: 44100,
                  sampleSize: 16
              } 
          });
          
          // Specify the MIME type and codec
          const options = {
              mimeType: 'audio/webm;codecs=opus',
              audioBitsPerSecond: 128000
          };
          
          // Fallback if the preferred format isn't supported
          if (!MediaRecorder.isTypeSupported(options.mimeType)) {
              console.log('Falling back to audio/webm');
              options.mimeType = 'audio/webm';
          }
          
          mediaRecorder = new MediaRecorder(stream, options);
          
          mediaRecorder.ondataavailable = (event) => {
              if (event.data.size > 0) {
                  audioChunks.push(event.data);
              }
          };
  
          let loadingInterval;
  
          mediaRecorder.onstop = async () => {
              // Convert WebM to WAV using audio context
              const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
              const audioContext = new (window.AudioContext || window.webkitAudioContext)();
              
              try {
                  const arrayBuffer = await audioBlob.arrayBuffer();
                  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                  
                  // Create WAV file
                  const wavBlob = await convertToWav(audioBuffer);
                  
                  const formData = new FormData();
                  formData.append('audio', wavBlob, 'recording.wav');
  
                  // Show loading indicator
                  document.getElementById('loadingText').style.display = 'block';
                  const loadingDots = document.getElementById('loadingDots');
                  let dotCount = 0;
  
                  loadingInterval = setInterval(() => {
                      dotCount = (dotCount + 1) % 4;
                      loadingDots.textContent = '.'.repeat(dotCount);
                  }, 500);
  
                  const response = await fetch('/add-note', {
                      method: 'POST',
                      body: formData
                  });
  
                  if (response.ok) {
                      window.location.reload();
                  } else {
                      throw new Error('Server response was not ok');
                  }
              } catch (error) {
                  console.error('Error processing audio:', error);
                  alert('Error processing audio. Please try again.');
              } finally {
                  document.getElementById('loadingText').style.display = 'none';
                  clearInterval(loadingInterval);
                  audioContext.close();
              }
  
              // Reset for next recording
              audioChunks = [];
              document.getElementById('startRecord').style.display = 'inline';
              document.getElementById('stopRecord').style.display = 'inline';
              document.getElementById('timer').style.display = 'inline';
          };
  
          // Start recording
          mediaRecorder.start(1000); // Collect data every second
          document.getElementById('startRecord').disabled = true;
          document.getElementById('stopRecord').disabled = false;
          
      } catch (err) {
          console.error('Error accessing microphone:', err);
          alert('Could not access microphone. Please ensure microphone permissions are granted.');
      }
  });
  
  // Function to convert AudioBuffer to WAV Blob
  function convertToWav(audioBuffer) {
      const numOfChannels = audioBuffer.numberOfChannels;
      const length = audioBuffer.length * numOfChannels * 2;
      const buffer = new ArrayBuffer(44 + length);
      const view = new DataView(buffer);
      const channels = [];
      let offset = 0;
      let pos = 0;
  
      // Write WAV header
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + length, true);
      writeString(view, 8, 'WAVE');
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numOfChannels, true);
      view.setUint32(24, audioBuffer.sampleRate, true);
      view.setUint32(28, audioBuffer.sampleRate * 2 * numOfChannels, true);
      view.setUint16(32, numOfChannels * 2, true);
      view.setUint16(34, 16, true);
      writeString(view, 36, 'data');
      view.setUint32(40, length, true);
  
      // Write audio data
      for (let i = 0; i < audioBuffer.numberOfChannels; i++) {
          channels.push(audioBuffer.getChannelData(i));
      }
  
      offset = 44;
      while (pos < audioBuffer.length) {
          for (let i = 0; i < numOfChannels; i++) {
              let sample = Math.max(-1, Math.min(1, channels[i][pos]));
              sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
              view.setInt16(offset, sample, true);
              offset += 2;
          }
          pos++;
      }
  
      return new Blob([buffer], { type: 'audio/wav' });
  }
  
  function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
      }
  }
  
  // Your existing timer code remains the same
  let startTime;
  let timerInterval;
  
  document.getElementById('startRecord').addEventListener('click', () => {
      startTime = new Date();
      timerInterval = setInterval(updateTimer, 1000);
  });
  
  function updateTimer() {
      const currentTime = new Date();
      const elapsedTime = currentTime - startTime;
      const totalSeconds = Math.floor(elapsedTime / 1000);
      const hours = Math.floor(totalSeconds / 3600).toString().padStart(2, '0');
      const minutes = Math.floor((totalSeconds % 3600) / 60).toString().padStart(2, '0');
      const seconds = (totalSeconds % 60).toString().padStart(2, '0');
      document.getElementById('timer').textContent = `${hours}:${minutes}:${seconds}`;
  }
  
  document.getElementById('stopRecord').addEventListener('click', () => {
      clearInterval(timerInterval);
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
      }
      document.getElementById('startRecord').disabled = false;
      document.getElementById('stopRecord').disabled = true;
  });
  
  function deleteNote(noteId) {
      fetch("/delete-note", {
          method: "POST",
          body: JSON.stringify({ noteId: noteId }),
      }).then((_res) => {
          window.location.href = "/";
      });
  }
</script>
{% endblock %}